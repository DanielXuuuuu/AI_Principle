#  中山大学数据科学与计算机学院本科生实验报告

| 课程名称 | 人工智能原理 | 任课老师     | 林倞     |
| -------- | ------------ | ------------ | -------- |
| 年级     | 17级         | 专业（方向） | 软件工程 |
| 学号     | 17343130     | 姓名         | 徐肯     |

## Assignment 1

### Spam Filters

###### 实验内容

给出一组训练集，其中包括垃圾邮件和正常邮件，使用贝叶斯原理实现一个垃圾邮件分类器，应该可以较为准确的区分出垃圾邮件。并给定测试集用于测试。

###### 问题分析与解题思路

原题给定训练样本数据，让我们基于这些数据让机器进行“学习”，然后对于测试邮件进行分类，实际上就是计算邮件是垃圾邮件的概率问题，是机器学习的入门算法。贝叶斯原理是该算法的核心思想，同时我们还假设了每个属性条件(对于邮件是单词)都是独立的，称为朴素贝叶斯（Naive Bayes）

贝叶斯原理为：$P(C/X) = \frac{P(X/C)* P(C)}{P(X)}$，其中X为属性条件，C为最后的结论，分别对应了本实验中的邮件所含单词和邮件类型。因此，根据贝叶斯原理，当我们已知一封邮件的内容时，要判断垃圾邮件的概率P(C/X)，就转化为了求P(X/C)以及P(X)，P(C)为先验概率，此处假定垃圾邮件和正常邮件概率相等，都为0.5

那么如何求P(X/C)以及P(X)呢，P(X/C)表示已知邮件类型求属性，也就是对应着我们需要知道一封垃圾邮件中可能会有哪些单词，这就用到了训练集，通过一些已知的分好类的邮件，帮助我们的机器学习单词出现在垃圾邮件和正常邮件的概率。而P(X)可以根据全概率得知。

以上就是贝叶斯分类器的原理。对于邮件分类更为细致的分析可以参考[博客](https://www.cnblogs.com/csguo/p/7804683.html)

因为Python中对于统计、集合等操作更为方便，我选择使用Python编写代码。

###### 程序流程

+ 遍历所有训练集邮件，得到总的单词集，并分别计算得到每个单词在正常邮件和垃圾邮件中出现的概率，即得到P(W/H)和P（W/S）
+ 对于每一封测试邮件：
  + 先验概率P(S) = P(H) = 50%
  + $P(S/W) = \frac{P(W/S)* P(S)}{P(W)} = \frac{P(W/S) * P(S)} {P(W/S) * P(S) + P(W/H) * P(H)} $
  + 对这封邮件中的每个单词计算联合概率，因为每个出现的不同单词都会对最终的分类结果起到影响
+ 若最后得到的概率大于0.5，则判断为垃圾邮件
+ 将判断结果和给定的测试标准结果比对，得到预测正确率

###### 提高准确率的方法

+ 在使用训练集计算每个单词在垃圾邮件和正常邮件出现的概率时，如果某个词只在垃圾邮件或者只在正常邮件出现，那么其在另一类型邮件出现的概率设为0.01，避免概率为0的情况。
+ 如果在扫描测试集中的邮件时，发现某个单词在之前训练时没有出现过，因而无法根据公式计算$P(S/W)$，此时可以假定概率为0.4。(因为垃圾邮件用的往往都是某些固定的词语，所以如果你从来没有见过某个词，它多半是一个正常的词)

###### 实验结果

本程序运行环境为Windows 10，Python版本为3.7.2，训练数据和测试数据均来自`ex6DataEmails`文件夹，在运行本程序时需要先修改程序中的绝对路径以正确读取数据。

以下截图为在VSCode中的运行结果，预测正确率为97.31%

![result](..\hw1\img\result1.png)

------

### A* Algorithm

###### 实验内容

给出以下城市的连通图，要求利用A*算法找到从A城市到B城市的最短路径，以及代价。其中，A、B可以为任意两个城市。

![paths](..\hw1\img\cities.png)

###### 问题分析与解题思路

题中指明要使用A*算法，那就不需要思考别的了，直接按照算法的思路来。A\*算法是一个十分典型的启发式搜索算法，一般用来寻找两点之间的最短路径。同传统的BFS、DFS这种Uninformed算法相比，它使用一个启发函数$f(x) = g(x) + h(x)$ 来对下一步进行评估，选择代价最小的子节点继续进行扩展，一定程度上避免了搜索的盲目性。

其中$g(x)$表示从起点到当前点$x$的花费(距离)，这是已知的，只需要在搜索过程中记录之前走的距离即可。而算法的关键是$h(x)$，算法的效率也取决于$h(x)$的设计是否合理。

设计好$h(x)$后，就很简单了。只需要使用一个**最小堆**即可，每次优先搜索$f(x)$最小的城市，直到达到目的地为止。

我看网上一般的A*算法都会使用一个OpenList和CloseList两个数据结构。CloseList用于记录一个节点是否已经访问过，但只需要用一个布尔值的数组记录就可以了。同时使用**最小堆**，保证每次访问的下一个结点都是代价最小的。如果某一个还未被访问的结点出现了更小的代价，也直接加入最小堆就行了，最小堆会帮助我们排好序。虽然这样会导致同一个节点在堆中同时存在好几个副本，但当我们取出最小的后，就将其标记为以访问，后续的直接舍弃即可。

但题目要求得到走过的路径，那么就必须对于一个结点，记录其父节点，即上一步。因此，这里可以使用CloseList解决，但其实**将bool数组换成Int类型**的就可以了。

###### h(x)的设计

> h(x)的设计应该比真实值小

由于题目已经给出的数据是每个城市到Bucharest的直线距离，这里我们注意到给出的直线距离普遍比按图中的路线走距离小。而我们题目要求实现对任意两个城市设计$h(x)$，那么我们可以利用三角形的一个很简单的性质：**两边之差小于第三边**来设计$h(x)$。即对于任意城市，将其已知的到Bucharest的直线长度看作三角形的两边，从而求出小于真实值的第三边，即$h(x)$。

###### 程序流程

+ 首先得到用户输入的需要求最短路径的两个城市
+ 

###### 实验结果

本程序运行环境为Windows 10，测试数据就是图中的数据，我直接写在程序中了。

以下是VSCode下的运行结果：



### 总结

A*算法之前还是有点接触过的，写起来并不是很难，但贝叶斯分类器还是第一次接触，同时课外有了解过一点Python的语法，这也是我第一次用Python写作业。

经过本次实验，在思考和查询朴素贝叶斯的写法时，让我对于机器学习方面有了一定的了解，个人认为